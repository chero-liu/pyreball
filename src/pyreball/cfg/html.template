<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title><!--PYREBALL_PAGE_TITLE--></title>
<!--PYREBALL_HEAD_LINKS-->
<style>
<!--PYREBALL_CSS_DEFINITIONS-->

/* ==================== 导航栏样式 ==================== */

/* 侧边栏容器：包裹整个页面，确保最小高度占满视口 */
.pyreball-sidebar-container {
  min-height: 100vh; /* 最小高度为视口高度 */
  font-family: var(--default-font, Times New Roman); /* 使用CSS变量中的字体，默认Times New Roman */
}

/* 侧边栏主样式 */
.pyreball-sidebar {
  width: auto; /* 宽度自适应内容 */
  min-width: 200px; /* 最小宽度200px */
  max-width: 320px; /* 最大宽度320px，防止过宽 */
  background-color: var(--surface-color,rgb(255, 255, 255)); /* 背景色，使用CSS变量 */
  border: 1px solid rgba(128, 128, 128, 0.5); /* 半透明灰色边框 */
  border-radius: 12px; /* 圆角边框 */
  padding: 20px; /* 内边距 */
  position: fixed; /* 固定定位，不随页面滚动 */
  right: 20px; /* 距离右侧20px */
  top: 20px; /* 距离顶部20px */
  max-height: calc(100vh - 40px); /* 最大高度为视口高度减去上下边距 */
  height: fit-content; /* 高度适应内容 */
  overflow-y: auto; /* 内容过多时垂直滚动 */
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1); /* 阴影效果 */
  z-index: 100; /* 确保在大多数内容上方 */
  transition: all 0.3s ease; /* 所有属性变化有0.3秒的过渡效果 */
  word-break: break-word; /* 长单词换行 */
  overflow-wrap: break-word; /* 溢出时断行 */
  cursor: move; /* 鼠标显示为移动光标，表示可拖拽 */
  user-select: none; /* 禁止用户选择文本 */
  resize: none; /* 禁止用户调整大小 */
}

/* 侧边栏顶部的拖拽手柄（使用伪元素实现） */
.pyreball-sidebar::before {
  content: ""; /* 必须设置content属性伪元素才生效 */
  position: absolute; /* 绝对定位 */
  top: 8px; /* 距离顶部8px */
  left: 50%; /* 水平居中 */
  transform: translateX(-50%); /* 向左平移自身宽度的一半实现居中 */
  width: 40px; /* 宽度40px */
  height: 4px; /* 高度4px */
  background-color: color-mix(in srgb, var(--default-color, #444444), transparent 70%); /* 混合颜色，70%透明 */
  border-radius: 2px; /* 圆角 */
  opacity: 0.5; /* 初始透明度50% */
  transition: opacity 0.3s ease; /* 透明度变化有过渡效果 */
}

/* 鼠标悬停在侧边栏时显示拖拽手柄 */
.pyreball-sidebar:hover::before {
  opacity: 1; /* 完全不透明 */
}

/* 拖拽过程中的侧边栏样式 */
.pyreball-sidebar.dragging {
  opacity: 0.9; /* 轻微透明 */
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2); /* 更深的阴影 */
  transition: none; /* 拖拽时禁用过渡动画，避免卡顿 */
}

/* ==================== 正文内容区域 ==================== */

/* 主要内容容器 */
.pyreball-content {
  max-width: 800px; /* 最大宽度800px */
  margin: 0 auto; /* 水平居中 */
  padding: 40px; /* 内边距 */
  position: relative; /* 相对定位，为子元素定位提供参考 */
  z-index: 1; /* 确保在侧边栏下方（侧边栏z-index为100） */
}

/* ==================== 目录列表样式 ==================== */

/* 目录容器 */
.pyreball-toc {
  list-style: none; /* 移除列表默认样式 */
  padding: 0; /* 无内边距 */
  margin: 0; /* 无外边距 */
  width: 100%; /* 宽度100% */
}

/* 目录项 */
.pyreball-toc li {
  margin-bottom: 6px; /* 底部外边距6px */
  position: relative; /* 相对定位 */
}

/* 目录链接 */
.pyreball-toc a {
  display: flex; /* 弹性布局 */
  align-items: center; /* 垂直居中对齐 */
  padding: 8px 12px; /* 内边距 */
  color: var(--default-color, #444444); /* 文字颜色，使用CSS变量 */
  text-decoration: none; /* 移除下划线 */
  border-radius: 6px; /* 圆角 */
  border: 1px solid transparent; /* 透明边框，为hover状态预留 */
  transition: all 0.3s ease; /* 所有属性变化有过渡效果 */
  font-size: 14px; /* 字体大小14px */
  border-right: 3px solid transparent; /* 右侧边框，用于active状态 */
  overflow: hidden; /* 溢出隐藏 */
  text-overflow: ellipsis; /* 文本溢出显示省略号 */
  white-space: nowrap; /* 不换行 */
  cursor: pointer; /* 鼠标指针为手型 */
}

/* 非拖拽状态下目录链接的悬停效果 */
.pyreball-sidebar:not(.dragging) .pyreball-toc a:hover {
  white-space: normal; /* 允许换行 */
  word-break: break-word; /* 单词内断行 */
}

/* 目录链接悬停样式 */
.pyreball-sidebar:not(.dragging) .pyreball-toc a:hover {
  background-color: color-mix(in srgb, var(--accent-color,rgb(52, 85, 183)), transparent 90%); /* 背景色，主色调90%透明 */
  color: var(--accent-color, rgb(52, 85, 183)); /* 文字颜色变为主题色 */
  border-right-color: var(--accent-color, rgb(52, 85, 183)); /* 右侧边框颜色变为主题色 */
  border-color: color-mix(in srgb, var(--accent-color, rgb(52, 85, 183)), transparent 70%); /* 边框颜色，主色调70%透明 */
  transform: translateX(-3px); /* 向左轻微移动，产生动态效果 */
}

/* 当前活动章节的链接样式 */
.pyreball-toc a.active {
  background-color: color-mix(in srgb, var(--accent-color, rgb(52, 85, 183)), transparent 85%); /* 背景色，85%透明 */
  color: var(--accent-color, rgb(52, 85, 183)); /* 文字颜色为主题色 */
  border-right-color: var(--accent-color, rgb(52, 85, 183)); /* 右侧边框颜色为主题色 */
  border-color: color-mix(in srgb, var(--accent-color, rgb(52, 85, 183)), transparent 50%); /* 边框颜色，50%透明 */
  font-weight: 500; /* 中等字重 */
}

/* 子目录容器 */
.toc-children {
  list-style: none; /* 移除列表样式 */
  padding-left: 20px; /* 左侧内边距20px，实现缩进 */
  margin: 5px 0; /* 上下外边距5px */
  max-height: 0; /* 初始最大高度为0，折叠状态 */
  overflow: hidden; /* 溢出隐藏 */
  transition: max-height 0.3s ease; /* 高度变化有过渡效果 */
  border-left: 1px dashed color-mix(in srgb, var(--default-color, #444444), transparent 70%); /* 左侧虚线边框 */
  border-radius: 0 0 0 8px; /* 左下角圆角 */
}

/* 展开状态下的子目录 */
.toc-has-children.expanded > .toc-children {
  max-height: 1000px; /* 设置一个足够大的值，实现展开动画 */
}

/* ==================== 各级标题样式 ==================== */

/* 二级标题 */
.pyreball-toc .toc-h2 {
  padding-left: 20px; /* 左侧内边距20px */
  font-size: 13.5px; /* 字体大小13.5px */
}

/* 三级标题 */
.pyreball-toc .toc-h3 {
  padding-left: 35px; /* 左侧内边距35px */
  font-size: 13px; /* 字体大小13px */
  color: color-mix(in srgb, var(--default-color, #444444), transparent 20%); /* 颜色，20%透明 */
}

/* 四级标题 */
.pyreball-toc .toc-h4 {
  padding-left: 50px; /* 左侧内边距50px */
  font-size: 12.5px; /* 字体大小12.5px */
  color: color-mix(in srgb, var(--default-color, #444444), transparent 30%); /* 颜色，30%透明 */
}

/* 五级标题 */
.pyreball-toc .toc-h5 {
  padding-left: 65px; /* 左侧内边距65px */
  font-size: 12px; /* 字体大小12px */
  color: color-mix(in srgb, var(--default-color, #444444), transparent 40%); /* 颜色，40%透明 */
}

/* 六级标题 */
.pyreball-toc .toc-h6 {
  padding-left: 80px; /* 左侧内边距80px */
  font-size: 11.5px; /* 字体大小11.5px */
  color: color-mix(in srgb, var(--default-color, #444444), transparent 50%); /* 颜色，50%透明 */
}

/* ==================== 返回顶部按钮 ==================== */

.pyreball-back-to-top {
  position: fixed; /* 固定定位 */
  bottom: 30px; /* 距离底部30px */
  right: 30px; /* 距离右侧30px */
  background-color: var(--accent-color, rgb(52, 85, 183)); /* 背景色为主题色 */
  color: white; /* 文字颜色白色 */
  width: 50px; /* 宽度50px */
  height: 50px; /* 高度50px */
  border-radius: 50%; /* 圆形 */
  display: flex; /* 弹性布局 */
  align-items: center; /* 垂直居中 */
  justify-content: center; /* 水平居中 */
  text-decoration: none; /* 移除下划线 */
  opacity: 0; /* 初始完全透明 */
  visibility: hidden; /* 初始不可见 */
  transition: all 0.3s ease; /* 所有属性变化有过渡效果 */
  z-index: 99; /* 在侧边栏下方（侧边栏z-index为100） */
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* 阴影效果 */
  border: 2px solid white; /* 白色边框 */
}

/* 按钮可见状态 */
.pyreball-back-to-top.visible {
  opacity: 1; /* 完全不透明 */
  visibility: visible; /* 可见 */
}

/* 按钮悬停效果 */
.pyreball-back-to-top:hover {
  background-color: var(--accent-dark, rgb(17, 47, 134)); /* 背景色变深 */
  transform: translateY(-3px); /* 向上移动3px */
  border-color: var(--accent-color, rgb(255, 255, 255)); /* 边框颜色为主题色 */
}

/* ==================== 主容器调整 ==================== */

.pyreball-main-container {
  width: 100% !important; /* 宽度100%，!important确保优先级 */
  margin: 0; /* 无外边距 */
  padding: 0; /* 无内边距 */
  box-shadow: none; /* 无阴影 */
  background-color: transparent; /* 透明背景 */
}

/* ==================== 侧边栏滚动条样式 ==================== */

.pyreball-sidebar::-webkit-scrollbar {
  width: 6px; /* 滚动条宽度6px */
}

.pyreball-sidebar::-webkit-scrollbar-track {
  background: color-mix(in srgb, var(--default-color, #444444), transparent 90%); /* 轨道颜色，90%透明 */
  border-radius: 3px; /* 圆角 */
}

.pyreball-sidebar::-webkit-scrollbar-thumb {
  background: color-mix(in srgb, var(--default-color, #444444), transparent 60%); /* 滑块颜色，60%透明 */
  border-radius: 3px; /* 圆角 */
}

.pyreball-sidebar::-webkit-scrollbar-thumb:hover {
  background: color-mix(in srgb, var(--default-color, #444444), transparent 40%); /* 滑块悬停颜色，40%透明 */
}
</style>
</head>
<body>
<!-- 侧边栏容器：包裹整个页面内容 -->
<div class="pyreball-sidebar-container">
  <!-- 主要内容区域 -->
  <main class="pyreball-content">
    <!-- 原有内容容器 -->
    <div class="pyreball-main-container">
      <!--PYREBALL_REPORT_CONTENTS-->
    </div>
  </main>
  
  <!-- 侧边栏导航 -->
  <aside class="pyreball-sidebar" id="sidebar">
    <nav class="pyreball-toc" id="tableOfContents">
      <div class="toc-loading">正在生成目录...</div> <!-- 目录加载中的占位文本 -->
    </nav>
  </aside>
</div>

<!-- 返回顶部按钮 -->
<a href="#" class="pyreball-back-to-top" id="backToTop">
  <span>↑</span> <!-- 向上箭头符号 -->
</a>

<script>
// 目录生成与交互功能
// DOMContentLoaded事件：当HTML文档完全加载和解析完成后触发
document.addEventListener('DOMContentLoaded', function() {
  // 获取页面中所有标题元素
  const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
  // 获取目录容器
  const tocContainer = document.getElementById('tableOfContents');
  // 获取侧边栏元素
  const sidebar = document.getElementById('sidebar');
  
  // 如果页面中有标题元素，生成目录
  if (headings.length > 0) {
    // 用于构建目录树结构的数组
    const tree = [];
    // 用于构建层次结构的栈
    const stack = [];
    
    // 遍历所有标题元素
    headings.forEach((heading, index) => {
      // 如果标题没有id，为其生成一个唯一的id
      if (!heading.id) {
        heading.id = 'section-' + index;
      }
      
      // 获取标题级别（h1=1, h2=2, ...）
      const level = parseInt(heading.tagName.substring(1));
      // 获取标题文本，移除可能的段落符号并去除首尾空格
      const text = heading.textContent.replace(/¶/g, '').trim();
      // 获取标题id
      const id = heading.id;
      
      // 创建目录节点对象
      const node = {
        level: level,      // 标题级别
        text: text,        // 标题文本
        id: id,            // 标题id（用于锚点链接）
        children: []       // 子节点数组
      };
      
      // 构建树形结构：从栈中弹出级别大于等于当前级别的节点
      // 直到找到父节点或栈为空
      while (stack.length > 0 && stack[stack.length - 1].level >= level) {
        stack.pop();
      }
      
      // 如果栈为空，当前节点是根节点
      if (stack.length === 0) {
        tree.push(node);
      } else {
        // 否则，当前节点是栈顶节点的子节点
        stack[stack.length - 1].children.push(node);
      }
      
      // 将当前节点压入栈中
      stack.push(node);
    });
    
    // 递归构建目录HTML
    function buildTOCHTML(nodes) {
      let html = '';
      
      // 遍历节点数组
      nodes.forEach((node) => {
        // 检查是否有子节点
        const hasChildren = node.children.length > 0;
        
        // 根据节点级别确定CSS类名
        let tocClass = '';
        if (node.level === 1) tocClass = 'toc-h1';
        else if (node.level === 2) tocClass = 'toc-h2';
        else if (node.level === 3) tocClass = 'toc-h3';
        else if (node.level === 4) tocClass = 'toc-h4';
        else if (node.level === 5) tocClass = 'toc-h5';
        else if (node.level === 6) tocClass = 'toc-h6';
        
        // 如果有子节点，创建可展开的目录项
        if (hasChildren) {
          html += `
            <li class="toc-has-children ${tocClass}" data-level="${node.level}">
              <a href="#${node.id}" title="${node.text}">
                ${node.text}
              </a>
              <ul class="toc-children">
                ${buildTOCHTML(node.children)}
              </ul>
            </li>
          `;
        } else {
          // 如果没有子节点，创建普通目录项
          html += `
            <li class="${tocClass}" data-level="${node.level}">
              <a href="#${node.id}" title="${node.text}">
                ${node.text}
              </a>
            </li>
          `;
        }
      });
      
      return html;
    }
    
    // 生成目录HTML并插入到容器中
    const tocHTML = buildTOCHTML(tree);
    tocContainer.innerHTML = tocHTML;
    
    // 计算并设置侧边栏宽度，使其适应内容
    function calculateAndSetSidebarWidth() {
      const tocLinks = tocContainer.querySelectorAll('a');
      let maxWidth = 200; // 最小宽度
      
      // 创建临时span元素用于测量文本宽度
      const tempSpan = document.createElement('span');
      tempSpan.style.visibility = 'hidden'; // 隐藏元素
      tempSpan.style.position = 'absolute'; // 绝对定位，不影响页面布局
      tempSpan.style.whiteSpace = 'nowrap'; // 不换行
      tempSpan.style.fontSize = '14px'; // 与目录链接字体大小一致
      tempSpan.style.fontFamily = 'inherit'; // 继承字体
      document.body.appendChild(tempSpan); // 添加到文档中以便测量
      
      // 测量所有链接的文本宽度
      tocLinks.forEach(link => {
        const text = link.textContent || link.innerText;
        tempSpan.textContent = text;
        
        // 根据标题级别计算缩进值
        let indent = 0;
        const li = link.closest('li');
        if (li) {
          if (li.classList.contains('toc-h2')) indent = 20;
          else if (li.classList.contains('toc-h3')) indent = 35;
          else if (li.classList.contains('toc-h4')) indent = 50;
          else if (li.classList.contains('toc-h5')) indent = 65;
          else if (li.classList.contains('toc-h6')) indent = 80;
        }
        
        // 总宽度 = 文本宽度 + 缩进 + 内边距和边框等额外空间
        const textWidth = tempSpan.offsetWidth + indent + 40;
        
        // 更新最大宽度，但不超过320px
        if (textWidth > maxWidth) {
          maxWidth = Math.min(textWidth, 320);
        }
      });
      
      // 移除临时元素
      document.body.removeChild(tempSpan);
      // 设置侧边栏宽度
      sidebar.style.width = `${maxWidth}px`;
    }
    
    // 初始化展开状态：默认展开第一个h1标题
    const h1Items = document.querySelectorAll('.toc-has-children.toc-h1');
    if (h1Items.length > 0) {
      h1Items[0].classList.add('expanded');
      const firstH1Id = h1Items[0].querySelector('a').getAttribute('href');
      // 将展开状态保存到本地存储
      localStorage.setItem(`pyreball-toc-${firstH1Id}`, 'true');
      
      // 折叠其他h1标题
      for (let i = 1; i < h1Items.length; i++) {
        h1Items[i].classList.remove('expanded');
        const otherH1Id = h1Items[i].querySelector('a').getAttribute('href');
        localStorage.setItem(`pyreball-toc-${otherH1Id}`, 'false');
      }
    }
    
    // 初始计算侧边栏宽度
    calculateAndSetSidebarWidth();
    
    // 监听窗口大小变化，重新计算侧边栏宽度（使用防抖技术）
    let resizeTimer;
    window.addEventListener('resize', function() {
      clearTimeout(resizeTimer); // 清除之前的定时器
      resizeTimer = setTimeout(calculateAndSetSidebarWidth, 250); // 延迟250ms执行，避免频繁计算
    });
  } else {
    // 如果没有标题，显示提示信息
    tocContainer.innerHTML = '<div class="toc-empty">暂无章节标题</div>';
  }
  
  // 为目录链接添加点击事件处理
  document.querySelectorAll('.pyreball-toc a').forEach(link => {
    link.addEventListener('click', function(e) {
      // 如果正在拖拽侧边栏，不执行链接点击
      if (sidebar.classList.contains('dragging')) {
        e.preventDefault();
        return;
      }
      
      e.preventDefault(); // 阻止默认的锚点跳转行为
      
      const targetId = this.getAttribute('href'); // 获取目标锚点id
      const targetElement = document.querySelector(targetId); // 获取目标元素
      const parentLi = this.closest('li'); // 获取父级li元素
      const isParentItem = parentLi.classList.contains('toc-has-children'); // 判断是否有子节点
      
      // 查找h1祖先元素（用于处理h1标题的折叠逻辑）
      let h1Ancestor = null;
      let currentElement = parentLi;
      while (currentElement) {
        if (currentElement.classList.contains('toc-h1')) {
          h1Ancestor = currentElement;
          break;
        }
        currentElement = currentElement.parentElement.closest('li');
      }
      
      // 处理h1标题的折叠逻辑
      if (h1Ancestor) {
        // 折叠所有其他展开的h1标题
        document.querySelectorAll('.toc-has-children.toc-h1.expanded').forEach(otherItem => {
          if (otherItem !== h1Ancestor) {
            otherItem.classList.remove('expanded');
            const otherItemId = otherItem.querySelector('a').getAttribute('href');
            localStorage.setItem(`pyreball-toc-${otherItemId}`, 'false');
          }
        });
        
        // 如果点击的h1标题未展开，则展开它
        if (!h1Ancestor.classList.contains('expanded')) {
          h1Ancestor.classList.add('expanded');
          const h1Id = h1Ancestor.querySelector('a').getAttribute('href');
          localStorage.setItem(`pyreball-toc-${h1Id}`, 'true');
        }
        
        // 处理非h1的父项（切换展开/折叠状态）
        if (isParentItem && parentLi !== h1Ancestor) {
          parentLi.classList.toggle('expanded');
          localStorage.setItem(`pyreball-toc-${targetId}`, parentLi.classList.contains('expanded'));
        }
      } else if (isParentItem) {
        // 如果没有h1祖先，直接切换展开/折叠状态
        parentLi.classList.toggle('expanded');
        localStorage.setItem(`pyreball-toc-${targetId}`, parentLi.classList.contains('expanded'));
      }
      
      // 平滑滚动到目标位置
      if (targetElement) {
        window.scrollTo({
          top: targetElement.offsetTop - 20, // 向上偏移20px，避免被固定导航栏遮挡
          behavior: 'smooth' // 平滑滚动
        });
        
        // 更新浏览器地址栏，但不刷新页面
        history.pushState(null, null, targetId);
      }
    });
    
    // 从本地存储加载保存的展开状态
    const parentLi = link.closest('.toc-has-children');
    if (parentLi) {
      const itemId = link.getAttribute('href');
      const savedState = localStorage.getItem(`pyreball-toc-${itemId}`);
      if (savedState === 'true') {
        parentLi.classList.add('expanded');
      } else if (savedState === 'false') {
        parentLi.classList.remove('expanded');
      }
    }
  });
  
  // 高亮当前阅读的章节
  function highlightCurrentSection() {
    const sections = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    const tocLinks = document.querySelectorAll('.pyreball-toc a');
    
    let currentSectionId = '';
    // 计算当前位置（加上100px偏移，让高亮更早触发）
    let scrollPosition = window.scrollY + 100;
    
    // 找出当前最接近的章节
    sections.forEach(section => {
      if (section.offsetTop <= scrollPosition) {
        currentSectionId = section.id;
      }
    });
    
    // 为对应的目录链接添加active类
    tocLinks.forEach(link => {
      link.classList.remove('active');
      if (link.getAttribute('href') === '#' + currentSectionId) {
        link.classList.add('active');
      }
    });
  }
  
  // 获取返回顶部按钮
  const backToTop = document.getElementById('backToTop');
  
  // 更新返回顶部按钮的可见性和当前章节高亮
  function updateBackToTop() {
    // 当滚动超过500px时显示返回顶部按钮
    if (window.scrollY > 500) {
      backToTop.classList.add('visible');
    } else {
      backToTop.classList.remove('visible');
    }
    
    // 更新当前章节高亮
    highlightCurrentSection();
  }
  
  // 监听滚动事件
  window.addEventListener('scroll', updateBackToTop);
  // 初始化更新
  updateBackToTop();
  
  // 返回顶部按钮点击事件
  if (backToTop) {
    backToTop.addEventListener('click', function(e) {
      e.preventDefault();
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    });
  }
  
  // ==================== 侧边栏拖拽功能 ====================
  
  let isDragging = false; // 是否正在拖拽
  let dragStartX, dragStartY; // 拖拽起始位置（鼠标坐标）
  let sidebarStartX, sidebarStartY; // 拖拽起始位置（侧边栏坐标）
  
  // 监听侧边栏的鼠标按下事件
  sidebar.addEventListener('mousedown', startDrag);
  
  // 开始拖拽
  function startDrag(e) {
    // 如果点击的是链接，不触发拖拽
    if (e.target.tagName === 'A' || e.target.closest('a')) {
      return;
    }
    
    isDragging = true;
    sidebar.classList.add('dragging');
    
    // 记录起始位置
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    
    const sidebarRect = sidebar.getBoundingClientRect();
    sidebarStartX = sidebarRect.right; // 右侧距离
    sidebarStartY = sidebarRect.top;   // 顶部距离
    
    // 添加拖拽过程中的事件监听
    document.addEventListener('mousemove', onDrag);
    document.addEventListener('mouseup', stopDrag);
    
    // 防止文本选择和默认拖拽行为
    e.preventDefault();
  }
  
  // 拖拽过程中
  function onDrag(e) {
    if (!isDragging) return;
    
    // 计算移动距离
    const deltaX = e.clientX - dragStartX;
    const deltaY = e.clientY - dragStartY;
    
    // 计算新位置
    const newRight = window.innerWidth - (sidebarStartX + deltaX);
    const newTop = sidebarStartY + deltaY;
    
    // 限制在视口范围内
    const maxRight = window.innerWidth - sidebar.offsetWidth - 10;
    const minRight = 10;
    const maxTop = window.innerHeight - sidebar.offsetHeight - 10;
    const minTop = 10;
    
    const constrainedRight = Math.max(minRight, Math.min(maxRight, newRight));
    const constrainedTop = Math.max(minTop, Math.min(maxTop, newTop));
    
    // 应用新位置
    sidebar.style.right = `${constrainedRight}px`;
    sidebar.style.top = `${constrainedTop}px`;
  }
  
  // 停止拖拽
  function stopDrag() {
    if (!isDragging) return;
    
    isDragging = false;
    sidebar.classList.remove('dragging');
    
    // 移除事件监听
    document.removeEventListener('mousemove', onDrag);
    document.removeEventListener('mouseup', stopDrag);
    
    // 保存位置到本地存储
    const sidebarRect = sidebar.getBoundingClientRect();
    localStorage.setItem('pyreball-sidebar-position', JSON.stringify({
      right: window.innerWidth - sidebarRect.right,
      top: sidebarRect.top
    }));
  }
  
  // 从本地存储加载保存的位置
  const savedPosition = localStorage.getItem('pyreball-sidebar-position');
  if (savedPosition) {
    try {
      const position = JSON.parse(savedPosition);
      // 确保位置在视口内
      const maxRight = window.innerWidth - sidebar.offsetWidth - 10;
      const minRight = 10;
      const maxTop = window.innerHeight - sidebar.offsetHeight - 10;
      const minTop = 10;
      
      const constrainedRight = Math.max(minRight, Math.min(maxRight, position.right));
      const constrainedTop = Math.max(minTop, Math.min(maxTop, position.top));
      
      // 应用保存的位置
      sidebar.style.right = `${constrainedRight}px`;
      sidebar.style.top = `${constrainedTop}px`;
    } catch (e) {
      console.error('Failed to parse saved sidebar position:', e);
    }
  }
});
</script>
<!--PYREBALL_INLINE_HIGHLIGHT_SCRIPT-->
</body>
</html>